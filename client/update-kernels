#!/bin/sh -e

# this script is run either chrooted on the server, or by a client with write
# access to the NFS mount point. (much of this code was originally in
# server/ltsp-update-kernels). --vagrant 20060801

if [ -f /etc/ltsp/update-kernels.conf ]; then
    . /etc/ltsp/update-kernels.conf
fi

BOOT=${BOOT:-"/boot"}
SUB_ARCH=${SUB_ARCH:-"$(uname -m)"}
VENDOR=${VENDOR:-"$(lsb_release -i -s)"}

case $0 in
  /etc/kernel/post*.d*) QUIET=true
esac

msg() {
    if [ "$QUIET" != "true" ]; then
       echo $@
    fi
}

if [ -z "$CHROOT_NAME" ]; then
    # FIXME: replace with a common function
    CHROOT_NAME="$(dpkg --print-installation-architecture)"
fi

if [ -z "$BOOTPROMPT_OPTS" ]; then
    if [ "$VENDOR" = "Ubuntu" ]; then
        BOOTPROMPT_OPTS="quiet splash"
    elif [ "$VENDOR" = "Debian" ]; then
        BOOTPROMPT_OPTS="root=/dev/nfs ip=dhcp boot=nfs"
    else
        BOOTPROMPT_OPTS="root=/dev/nfs ip=dhcp"
    fi
fi

if [ -f /usr/lib/yaboot/yaboot ]; then
    cp -a -v /usr/lib/yaboot/yaboot $BOOT
    cat > $BOOT/yaboot.conf <<EOF
timeout=0
default=ltsp
root=/dev/ram

image=/ltsp/$CHROOT_NAME/vmlinux
        label=ltsp
        initrd=/ltsp/$CHROOT_NAME/initrd.img
        append="$BOOTPROMPT_OPTS"
EOF

else
    msg "Skipping yaboot configuration. install yaboot package if you need it."
fi

if [ -f /usr/lib/syslinux/pxelinux.0 ]; then
    PXECFG=$BOOT/pxelinux.cfg
    cp /usr/lib/syslinux/pxelinux.0 $BOOT
    if [ ! -d $PXECFG ]; then
        mkdir $PXECFG
    fi
    if [ -z "$PXELINUX_CMDLINE" ]; then
        PXELINUX_CMDLINE="DEFAULT vmlinuz ro initrd=initrd.img $BOOTPROMPT_OPTS"
    fi
    cat > $PXECFG/default <<EOF
$PXELINUX_CMDLINE
EOF

else
    msg "Skipping PXE configuration.  Install the syslinux package if you need it."
fi

# allow specifying a specific kernel image to update, from kernel postinst
if [ -f "$2" ]; then
    ALL_KERNELS="$2"
else
    ALL_KERNELS="$(find $BOOT -type f -name 'vmlinu*')"
fi

# look for symlinks, too, and put them after the "real" kernels
ALL_KERNELS="$ALL_KERNELS $(find $BOOT -type l -name 'vmlinu*')"

for kernel in $ALL_KERNELS ; do
    basename=$(basename "$kernel")
    initrd=initrd.img
    nbi=nbi.img

    case $basename in
        vmlinuz|vmlinux)
            # USE DEFAULT
        ;;
        vmlinu*.old) 
            initrd=$initrd.old
            nbi=$nbi.old
        ;;
        vmlinuz*) 
            version=${basename##vmlinuz-}
            initrd=$initrd-$version
            nbi=$nbi-$version
        ;;
        vmlinux*) 
            version=${basename##vmlinux-}
            initrd=$initrd-$version
            nbi=$nbi-$version
        ;;
    esac

    if [ -L "$kernel" ]; then
        basename="$(readlink $kernel)"
        if [ -f "$BOOT/$basename" ]; then
            case $basename in
                vmlinuz*)
                    version=${basename##vmlinuz-}
                ;;
                vmlinux*)
                    version=${basename##vmlinux-}
                ;;
            esac
            case $SUB_ARCH in
                sparc*) 
                    realnbi="nbi.img-$version-$SUB_ARCH"
                ;;
                *)
                    realnbi="nbi.img-$version"
                ;;
            esac
            if [ -f "$BOOT/$realnbi" ]; then
                ln -sf $realnbi $BOOT/$nbi
            fi
        fi
    else
        if which mkelfImage >/dev/null; then
            # x86_64/amd64 i386 ia64(?): mkelfimage
            MKELFIMAGE_INITRD_OPT=""
            if [ -z "$MKELFIMAGE_OPTS" ]; then
                MKELFIMAGE_OPTS="$BOOTPROMPT_OPTS"
            fi
            if [ -f "$BOOT/$initrd" ]; then
                MKELFIMAGE_INITRD_OPT="--ramdisk=$BOOT/$initrd"
            fi
            mkelfImage --command-line="$MKELFIMAGE_OPTS" --output=$BOOT/$nbi.tmp \
                --kernel=$kernel $MKELFIMAGE_INITRD_OPT && mv $BOOT/$nbi.tmp $BOOT/$nbi
        elif which mkelf-linux >/dev/null; then
            # i386: mknbi
            MKELF_LINUX_INITRD_OPT=""
            if [ -z "$MKELF_LINUX_APPEND" ]; then
                MKELF_LINUX_APPEND="$BOOTPROMPT_OPTS"
            fi
            if [ -f "$BOOT/$initrd" ]; then
                MKELF_LINUX_INITRD_OPT="$BOOT/$initrd"
            fi
            mkelf-linux $MKELF_LINUX_OPTS --append="$MKELF_LINUX_APPEND" \
                -o $BOOT/$nbi $kernel $MKELF_LINUX_INITRD_OPT
        else
            if [ -z "$mkelf_seen" ]; then
                mkelf_seen=true
                msg "Skipping etherboot images.  Install the mkelfimage package if you need them."
            fi
        fi
        if which netabootwrap >/dev/null; then
            # alpha: aboot
            ABOOT_INITRD_OPT=""
            if [ -f "$BOOT/$initrd" ]; then
                ABOOT_INITRD_OPT="-i $BOOT/$initrd"
            fi
            netabootwrap -t $BOOT/$nbi -k $kernel $ABOOT_INITRD_OPT
        else
            if [ -z "$netabootwrap_seen" ]; then
                netabootwrap_seen=true
                msg "Skipping netabootwrap images.  Install the aboot package if you need them."
            fi
        fi
        if which elftoaout >/dev/null ; then
            # sparc: sparc-utils
            SPARC_INITRD_OPT=""
            piggyback_cmd=""
            case $SUB_ARCH in
                sparc64) piggyback_cmd=piggyback64 ;;
                sparc32) piggyback_cmd=piggyback32 ;;
            esac
            sysmap=$BOOT/System.map-$version
            nbi=$nbi-$SUB_ARCH

            # TODO: proper tempfile handline
            gzip -cd $kernel > $BOOT/$nbi.tmp
            elftoaout -o $BOOT/$nbi $BOOT/$nbi.tmp
            rm $BOOT/$nbi.tmp
            if [ -f "$BOOT/$initrd" ]; then
                SPARC_INITRD_OPT="$BOOT/$initrd"
            fi
            $piggyback_cmd $BOOT/$nbi $sysmap $SPARC_INITRD_OPT
        else
            if [ -z "$sparc_piggyback_seen" ]; then
                sparc_piggyback_seen=true
                msg "Skipping sparc piggyback images. Install the sparc-utils package if you need them."
            fi
        fi
        if which tip22 >/dev/null ; then
            # mips: tip22
            case $kernel in
                *ip32*) tip=tip32 ;;
                *) tip=tip22 ;;
            esac
            if [ ! -f "$BOOT/$initrd" ]; then
                # feed a fake initrd, as tip* requires it 
                dd if=/dev/zero of="$BOOT/$initrd" bs=1 count=1
            fi
            $tip $kernel $BOOT/$initrd $BOOT/$nbi.tmp && mv $BOOT/$nbi.tmp $BOOT/$nbi
        fi
    fi
done
